# HWP 미주 기반 파싱 과정 상세 가이드

## 개요

이 문서는 HWP 문서에서 미주(Endnote)를 기반으로 문제를 추출하는 파싱 과정을 상세히 설명합니다. `endnote_save.py`를 참고하여 구현되었으며, `pyhwpx` 라이브러리를 사용합니다.

## 핵심 원칙

1. **미주 앵커 = 문제 시작점**: 본문의 미주 번호(①, ②, ③...) 위치가 각 문제의 시작점입니다.
2. **다음 미주 직전 또는 "노블록" = 문제 끝점**: 각 문제의 끝점은 다음 미주 직전 위치이거나, 마지막 문제의 경우 "노블록" 마커 위치입니다.
3. **HeadCtrl 기반 안정적인 미주 탐색**: HWP의 HeadCtrl을 사용하여 모든 미주 컨트롤을 안정적으로 찾습니다.
4. **뒤에서부터 처리**: 문서 구조를 유지하기 위해 마지막 문제부터 역순으로 처리합니다.
5. **본문만 수정, 주석 영역은 건드리지 않음**: 본문의 빈줄만 제거하고, 주석(미주 본문) 영역의 빈줄은 제거하지 않습니다.

## 전체 파싱 순서

### 0단계: 문서 열기
- `pyhwpx.Hwp()` 객체 생성
- `hwp.open(hwp_path)`로 HWP 파일 열기

### 1단계: 문서 정리 (준비 작업)
**목적**: 문서 구조를 단순화하여 위치 계산을 정확하게 합니다.

**작업 내용**:
1. **1단 설정**: 문서를 1단으로 설정 (`PageSetup`, `ColumnCount = 1`)
2. **단나누기 제거**: CtrlID 18인 단나누기 컨트롤 제거 (`DeleteCtrls`)
3. **쪽나누기 제거**: CtrlID 19인 쪽나누기 컨트롤 제거 (`DeleteCtrls`)

**함수**: `_prepare_document_pyhwpx()`

**주의사항**:
- 실패해도 계속 진행 (경고만 출력)
- 대체 방법으로 각각 따로 제거 시도

---

### 2단계: 본문 빈줄 제거 (본문스캔만)
**목적**: 본문의 연속된 빈줄을 제거하여 깔끔하게 만듭니다.

**작업 내용**:
1. **미주 앵커 임시 수집**: 빈줄 제거를 위해 미주 위치를 먼저 찾습니다.
2. **빈 줄 길이 측정**: 문서 끝에 공백을 넣고 선택 길이를 측정하여 빈 줄의 기준 길이를 구합니다.
3. **본문 빈줄 제거**: 각 미주 위쪽의 연속된 빈 문단을 삭제합니다.
   - 마지막 미주부터 역순으로 처리
   - 각 미주 앵커 위치로 이동
   - 이전 문단으로 이동 (`move_pos(11)` = `movePrevPara`)
   - 연속된 빈 문단 삭제 (`DeleteBack`)
   - 첫 번째 미주는 `BreakPara()` 실행하지 않음 (불필요한 엔터 추가 방지)

**함수**: 
- `_remove_blank_lines_pyhwpx()`: 빈줄 제거 메인 함수
- `_measure_blank_line_length_pyhwpx()`: 빈 줄 길이 측정 (emp 함수)
- `_scan_and_remove_blank_lines_pyhwpx()`: 본문 빈줄 스캔 및 제거 (본문스캔 함수)
- `_is_blank_line_pyhwpx()`: 빈 줄 판정 (isb 함수)

**주의사항**:
- **미주 본문(주석 영역) 정리는 하지 않음**: `_clean_endnote_bodies_pyhwpx()` 호출 제거
- 빈줄 판정 오류 시 본문이 삭제될 수 있으므로 주의 필요
- 표 안에서는 빈줄 제거 중단 (`is_cell()` 체크)

---

### 3단계: 미주 앵커 위치 수집 (최종)
**목적**: 빈줄 제거 후 변경된 위치를 반영하여 미주 앵커 위치를 다시 수집합니다.

**작업 내용**:
1. **HeadCtrl로 모든 미주 컨트롤 찾기**: `hwp.HeadCtrl`로 모든 컨트롤 순회
2. **미주 컨트롤 확인**: `CtrlID == "en"`인 컨트롤 찾기
3. **미주 앵커 위치 가져오기**: `c.GetAnchorPos(0)`로 본문의 미주 번호 위치 가져오기
4. **위치 저장**: 각 미주 앵커 위치를 리스트에 저장

**함수**: `_collect_endnote_anchors_pyhwpx()` (ena 함수)

**반환값**: `[(sec, para, pos), ...]` - 각 미주 앵커의 위치 리스트

**주의사항**:
- 미주를 찾을 수 없으면 파싱 중단
- 빈줄 제거 후 위치가 변경되었으므로 반드시 다시 수집해야 함

---

### 4단계: 각 미주의 끝점 계산
**목적**: 각 문제의 끝점을 정확하게 계산합니다.

**작업 내용**:
1. **일반 미주 (마지막 문제 제외)**:
   - 다음 미주 위치로 이동
   - 왼쪽으로 한 칸 이동 (`MoveLeft`) - 다음 미주 직전 위치
   - 이 위치가 현재 문제의 끝점

2. **마지막 미주**:
   - "노블록" 마커 위치 찾기 (`_find_noblock_position_pyhwpx()`)
   - 마지막 미주에서 "노블록"까지 가는 중에 단나누기/페이지나누기 확인
   - 단나누기/페이지나누기 직전 위치로 제한 (`_find_end_position_before_breaks_pyhwpx()`)
   - 다음 페이지 내용이 포함되지 않도록 보장

**함수**: 
- `_calculate_endnote_end_positions_pyhwpx()` (ene 함수)
- `_find_noblock_position_pyhwpx()` (nob 함수)
- `_find_end_position_before_breaks_pyhwpx()`: 단나누기/페이지나누기 직전 위치 찾기

**반환값**: `[(sec, para, pos), ...]` - 각 미주의 끝점 위치 리스트

**주의사항**:
- 미주 앵커 수와 끝점 수가 일치하지 않으면 파싱 중단
- 마지막 문제의 경우 단나누기/페이지나누기 직전까지로 제한

---

### 5단계: 뒤에서부터 문제 블록 추출 및 저장
**목적**: 각 문제를 개별 파일로 추출하여 저장합니다.

**작업 순서**: 마지막 문제부터 역순으로 처리 (뒤에서부터)

**각 문제마다 수행하는 작업**:
1. **시작 위치로 이동**: `_set_pos_pyhwpx(hwp, anchor_pos)`
2. **선택 시작**: `hwp.Run("Select")`
3. **끝 위치로 이동**: `_set_pos_pyhwpx(hwp, end_pos)` (범위 선택 유지)
4. **선택된 내용 복사**: `hwp.Run("Copy")`
5. **선택 해제**: `hwp.Run("Cancel")`
6. **새 문서 생성**: `FileNew` (기본 서식)
7. **붙여넣기**: `hwp.Run("Paste")`
8. **미주 스타일 적용**: `_apply_endnote_styles_pyhwpx(hwp)` (새 문서에서)
   - 전체 글꼴 적용 (나눔고딕, 10pt, 줄간격 160%, 검정색)
   - 미주 스타일 적용 (세방고딕 Bold, 20pt, 줄간격 120%, RGB(43,45,99))
9. **파일 저장**: `FileSaveAs` (임시 파일로 저장)
10. **파일 읽기**: 저장한 파일을 바이너리로 읽기
11. **결과에 추가**: `results.append((hwp_bytes, text))`
12. **임시 파일 삭제**: `os.remove(temp_file)`
13. **새 문서 닫기**: `FileClose`

**함수**: `_select_and_save_block_pyhwpx()` (sel + sav 함수)

**주의사항**:
- 뒤에서부터 처리하여 문서 구조 유지
- 각 문제마다 새 문서를 생성하고 저장하므로 원본 문서는 변경되지 않음
- 실패해도 다음 문제 계속 처리

---

### 6단계: 순서 정리
**목적**: 뒤에서부터 처리했으므로 순서를 뒤집어 1번부터 정렬합니다.

**작업 내용**:
- `results.reverse()`: 결과 리스트를 뒤집기

---

### 7단계: 문서 닫기
**목적**: 원본 문서를 닫고 리소스를 해제합니다.

**작업 내용**:
- `hwp.Quit()`: HWP 문서 닫기

---

## 주요 함수 설명

### `_prepare_document_pyhwpx()`
문서 파싱 전 준비 작업을 수행합니다.
- 1단 설정
- 단나누기/쪽나누기 제거

### `_remove_blank_lines_pyhwpx()`
본문의 빈줄을 제거합니다.
- 빈 줄 길이 측정
- 본문스캔 실행 (미주 본문 정리는 제외)

### `_collect_endnote_anchors_pyhwpx()`
모든 미주 앵커 위치를 수집합니다.
- HeadCtrl로 모든 미주 컨트롤 찾기
- `GetAnchorPos(0)`로 본문의 미주 번호 위치 가져오기

### `_calculate_endnote_end_positions_pyhwpx()`
각 미주의 끝점을 계산합니다.
- 일반 미주: 다음 미주 직전
- 마지막 미주: "노블록" 또는 단나누기/페이지나누기 직전

### `_select_and_save_block_pyhwpx()`
범위를 선택하고 새 문서로 저장합니다.
- 시작점~끝점 범위 선택
- 복사 → 새 문서 붙여넣기 → 저장
- 미주 스타일 적용

---

## 중요 주의사항

### 1. 파싱 과정에서 절대 건드리면 안 되는 것
- **주석 영역 (미주 본문)**: 주석 영역의 빈줄 제거는 하지 않음
- **원본 문서**: 원본 문서는 읽기 전용으로 사용, 수정하지 않음

### 2. 빈줄 제거의 위험성
- 빈줄 판정 오류 시 본문이 삭제될 수 있음
- `blank_len` 측정이 부정확하면 문제 발생 가능
- 문서 구조(표, 그림, 수식 등)에 따라 결과가 달라질 수 있음

### 3. 위치 계산의 중요성
- 빈줄 제거 후 반드시 미주 앵커 위치를 다시 수집해야 함
- 끝점 계산 시 단나누기/페이지나누기를 고려해야 함

### 4. 뒤에서부터 처리하는 이유
- 앞에서부터 처리하면 문서 구조가 변경되어 위치 계산이 어긋날 수 있음
- 뒤에서부터 처리하면 이미 처리한 부분의 위치가 변경되지 않음

---

## 파싱 후 새 문서에서 수행하는 작업

파싱된 새 문서(한 문제짜리)에서 미주 스타일을 적용합니다:

1. **전체 글꼴 적용**: 나눔고딕, 10pt, 줄간격 160%, 검정색
2. **미주 찾기**: 첫 번째 미주만 찾기 (반복문 사용 안 함)
3. **미주 옆 요소 확인**: 미주가 단독인지 확인
4. **미주 분리**: 미주 옆에 요소가 있으면 새 줄로 분리
5. **미주 스타일 적용**: 세방고딕 Bold, 20pt, 줄간격 120%, RGB(43,45,99)
6. **주석 진입**: `DialogResult 32`로 주석 진입
7. **주석 내부 스타일 적용**: 나눔고딕, 10pt, 줄간격 160%, 검정색
8. **주석 나가기**: `DialogResult 32` + `CloseEx`
9. **문서 끝 이동**: `MoveTopLevelEnd`

---

## 참고 자료

- `docs/endnote_save.py`: 원본 참고 스크립트
- `processors/hwp/problem_splitter.py`: 실제 구현 코드

---

## 변경 이력

- **최초 작성**: 미주 기반 파싱 구현
- **빈줄 제거 단계 제거**: 본문 삭제 위험 제거를 위해 미주 본문 정리 제거
- **본문 빈줄 제거 유지**: 본문만 깔끔하게 하기 위해 본문스캔만 유지
